# Diplomat

While tools like Cypress have evolved to provide concise, dependable end-to-end tests, these tools rely on driving a UI and asserting its state. What is lacking is a similarly concise, similarly dependable, similarly _enjoyable_ tool for driving an HTTP API and asserting its responses. Diplomat aims to meet that need.

Like most TD tools, this tool aims to codify the opinions of its authors for not only a technology, but its influence on the _process_ and _practice_ of making software. Diplomat is opinionated.

## About this Project

### Features

- Makes requests and asserts responses.
- Tests can be preceded by setup, and postceded by teardown.
  - Setup and teardown can be either request/response pairs (e.g. POST /resource) or running executables (e.g. DB migrations).
- Aspects of a test can be generated by user-provided code.

### Goals

- Language agnostic: This should work just as well for an ASP.NET project as a Rails one.
- Comprehensive: All aspects of a response can be asserted (status code, headers, entity, trailers, etc.).
- Strict by default: When something is not specified, the defaults should be as restrictive as possible, e.g. keys not specified in JSON entities are _forbidden_, rather than ignored.
- Concise: If such a default can be provided, it will be.
- Works for REST and GraphQL, etc.: Rather than tying the requests and responses to Resources or Queries, tests should be HTTP-specific, but no moreso.
- Speed: This tool should be fast enough to, if the underlying service is as performant, be used during feature development.

### Design

- Byte-for-byte comparisons work well:
  - Render request and response pair as template strings.
  - Make request.
  - Compare response, byte by byte, with the rendered version. For every template _matcher_ encountered, run the matcher.
- Needs to be smart about parsing headers, etc.
  - Example: Date header. It should be ignored from response assertions, but that requires _parsing_ the headers to know that.
  - Example: Host header. It should be dynamic, based on the host used for testing.
  - Example: HTTP version. It should be optional in response expectations, asserted if and only if present.
- Large bodies: Needs to be able to pull in other files via fixture, etc.

### Alternatives

- Superagent
- Frisby
- Dredd
- Roll-your-own

## Usage

To see the usage information for diplomat, pass the `--help` flag:

```sh
bin/diplomat --help
```

### Writing Specifications

In order to define a test in Diplomat, you'll need to provide what we call a _specification_. A specification is a file containing a request and its expected response.

Here's an extremely simple specification, that just checks for a status code (`examples/simple/pass.txt`):

```
You can put any amount of text above the specification in a text file.
Like comments, it will be ignored by the parser.

> GET /status/200 HTTP/1.1
>
< HTTP/1.1 200 OK
< Content-Length: 0
<
```

To run this specification as a test using Diplomat:

```
$ bin/diplomat examples/simple/pass.txt https://httpbin.org
GET /status/200 -> 200
```

The command doesn't output any diff information, which means the test passed. Let's look at a specification that we know will fail (`examples/simple/fail.txt`):

```
We don't expect this specification to pass, because the status code and text don't match!

> GET /status/200 HTTP/1.1
>
< HTTP/1.1 422 UNPROCESSABLE ENTITY
< Content-Length: 0
<
```

```
$ bin/diplomat examples/simple/fail.txt https://httpbin.org
GET /status/200 -> 422
Status:
        - 422 UNPROCESSABLE ENTITY
        + 200 OK
```

Running this specification through Diplomat provides output that `Status` is not expected.

Currently supported file extensions for specifications: `.txt`, `.md`, `.markdown`.

### Using Curl to Generate Specifications

Something we've kept in mind while developing this project is the concept of [runnable documentation](https://github.blog/2015-10-06-runnable-documentation/). The idea is that a Diplomat specification can be both documentation _and_ a test file. You can build and check in specifications alongside your source code, or create a quick one-off file that can be attached to a ticket to demonstrate an issue.

Specification syntax is based on the output you get from [`curl`'s `--verbose` option](https://ec.haxx.se/usingcurl-verbose.html). This means that you can quickly generate specifications from real API calls using `curl`.

For example:

```
$ curl --verbose https://httpbin.org/status/422
*   Trying 3.85.154.144...
* TCP_NODELAY set
* Connected to httpbin.org (3.85.154.144) port 443 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
* Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH
* successfully set certificate verify locations:
*   CAfile: /etc/ssl/cert.pem
  CApath: none
* TLSv1.2 (OUT), TLS handshake, Client hello (1):
* TLSv1.2 (IN), TLS handshake, Server hello (2):
* TLSv1.2 (IN), TLS handshake, Certificate (11):
* TLSv1.2 (IN), TLS handshake, Server key exchange (12):
* TLSv1.2 (IN), TLS handshake, Server finished (14):
* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):
* TLSv1.2 (OUT), TLS change cipher, Client hello (1):
* TLSv1.2 (OUT), TLS handshake, Finished (20):
* TLSv1.2 (IN), TLS change cipher, Client hello (1):
* TLSv1.2 (IN), TLS handshake, Finished (20):
* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256
* ALPN, server did not agree to a protocol
* Server certificate:
*  subject: CN=httpbin.org
*  start date: Feb 17 00:00:00 2019 GMT
*  expire date: Mar 17 12:00:00 2020 GMT
*  subjectAltName: host "httpbin.org" matched cert's "httpbin.org"
*  issuer: C=US; O=Amazon; OU=Server CA 1B; CN=Amazon
*  SSL certificate verify ok.
> GET /status/422 HTTP/1.1
> Host: httpbin.org
> User-Agent: curl/7.54.0
> Accept: */*
> 
< HTTP/1.1 422 UNPROCESSABLE ENTITY
< Access-Control-Allow-Credentials: true
< Access-Control-Allow-Origin: *
< Content-Type: text/html; charset=utf-8
< Date: Thu, 14 Mar 2019 20:48:15 GMT
< Server: nginx
< Content-Length: 0
< Connection: keep-alive
< 
* Connection #0 to host httpbin.org left intact
```

Notice that the sections in this `curl` output, particularly those prefixed by `>` and `<`, resemble the specification above. Simply delete any line starting with `*`, and any headers you don't need to verify.

### Alternate Printers

#### `--tap`

Diplomat supports tap output, by passing the `tap` flag:

```
$ bin/diplomat --tap examples/simple/pass.txt https://httpbin.org
TAP version 13
ok 0 GET /status/200 -> 200
```

#### `--debug`

The `debug` flag provides additional information about the differences between the specification's request and response. This flag should not be used in production.

```
$ bin/diplomat --debug examples/simple/pass.txt https://httpbin.org
GET /status/200 -> 200
{*http.Response}.Headers["Access-Control-Allow-Credentials"]:
        -: <non-existent>
        +: "true"
{*http.Response}.Headers["Access-Control-Allow-Origin"]:
        -: <non-existent>
        +: "*"
{*http.Response}.Headers["Connection"]:
        -: <non-existent>
        +: "keep-alive"
{*http.Response}.Headers["Content-Type"]:
        -: <non-existent>
        +: "text/html; charset=utf-8"
{*http.Response}.Headers["Date"]:
        -: <non-existent>
        +: "Mon, 18 Mar 2019 14:04:02 GMT"
{*http.Response}.Headers["Server"]:
        -: <non-existent>
        +: "nginx"
{*http.Response}.Body:
        -: []uint8(nil)
        +: []uint8{}
```

### Dynamic Validation

When validating an API, you may not want or be able to create response specifications using hard-coded values. Diplomat supports a combination of [Lua](https://www.lua.org/about.html) and [JSON Schema](https://json-schema.org/) to create more general specifications.

#### JSON Schemas

Diplomat provides a couple of Lua helpers in the global namespace, meaning that you can use them in your specifications. Let's look at `examples/json-schema/spec.txt`:

```
> POST /post HTTP/1.1
> Accept: text/plain
> Content-Type: application/json
The request body
< HTTP/1.1 200 OK
{? json_schema(file("examples/json-schema/post-schema.json")) ?}
```

The request is a typical specification, but the body of the response contains embedded code. In Diplomat, the syntax `{? ?}` is used to wrap Lua scripts. This example uses two methods provided by Diplomat:
- `file` takes a path, and grabs the contents of that file
- `json_schema` tells Diplomat to validate the response body by schema rather than by the literal JSON

The contents of `examples/json-schema/post-schema.json` follow the [JSON schema specification](https://json-schema.org/specification.html). This provides a bit more flexibility if you just want to check the existence of a single property, or confirm that a property has the correct type without knowing the exact value.

Notice that this schema only validates the top-level properties `data` and `headers`. It expects an exact value for the `Accept`, `Content-Length`, and `Content-Type` headers, but only cares about receiving a string for the `Host` and `User-Agent` headers. Check out the JSON schema specification for more templating options.

```json
{
  "type": "object",
  "additionalProperties": true,
  "required": [
    "data",
    "headers"
  ],
  "properties": {
    "data": {
      "type": "string",
      "const": "The request body\n"
    },
    "headers": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "Accept",
        "Content-Length",
        "Content-Type",
        "Host",
        "User-Agent"
      ],
      "properties": {
        "Accept": {
          "type": "string",
          "const": "text/plain"
        },
        "Content-Length": {
          "type": "string",
          "const": "17"
        },
        "Content-Type": {
          "type": "string",
          "const": "application/json"
        },
        "Host": {
          "type": "string"
        },
        "User-Agent": {
          "type": "string"
        }
      }
    }
  }
}
```

## Development

### Get the Source Code

This project uses a version of Go supporting [modules](https://blog.golang.org/modules2019), which means you can clone the repository anywhere you want. It also handles depdencies without need of secondary tooling such as Glide.

```sh
git clone git@github.com:testdouble/diplomat.git
cd diplomat
```

### Setup

Install [`go`](https://golang.org/doc/install):

```sh
# Mac OSX with Homebrew
brew install go
```

Install [`bats`](https://github.com/sstephenson/bats):

```sh
# Mac OSX with Homebrew
brew install bats
```

In order to develop on this repository, you'll also need to install [Docker](https://docs.docker.com/install/).

By default, we use a Docker image version of [`httpbin`](https://httpbin.org/) to make requests for the `bats` tests. If you prefer not to use Docker, change the value of `TEST_HOST` in `test/helpers/helpers.bash` to point to `https://httpbin.org`.

### Watch Code and Run Tests

The core development script in `Makefile` is `watch`:

```sh
make watch
```

This script uses `rg --files | entr -rc` to watch the code, and run several other `make` scripts on update. Those scripts can also be run on a one-off basis, if desired (see `Makefile`). The `watch` script provides a general-purpose, fast feedback cycle for development, which encourages making small changes and keeping tests green.

### Using Mocks

The unit tests in this repository use [`mockery`](http://docs.mockery.io/en/latest/) and [`testify`](https://github.com/stretchr/testify) to generate mocks for each `type` in the project. These mock files live in `mocks`, are checked into source control, and should _not_ be manually updated.

If you add or modify any `type`s, you will need to regenerate the mocks.

```sh
make generate
```

## Code of Conduct

This project follows Test Double's [code of conduct](https://testdouble.com/code-of-conduct) for all community interactions, including (but not limited to) one-on-one communications, public posts/comments, code reviews, pull requests, and GitHub issues. If violations occur, Test Double will take any action they deem appropriate for the infraction, up to and including blocking a user from the organization's repositories.
