# Diplomat

While tools like Cypress have evolved to provide concise, dependable end-to-end tests, these tools rely on driving a UI and asserting its state. What is lacking is a similarly concise, similarly dependable, similarly _enjoyable_ tool for driving an HTTP API and asserting its responses. Diplomat aims to meet that need.

Like most TD tools, this tool aims to codify the opinions of its authors for not only a technology, but its influence on the _process_ and _practice_ of making software. Diplomat is opinionated.

## About this Project

### Features

- Makes requests and asserts responses.
- Tests can be preceded by setup, and postceded by teardown.
  - Setup and teardown can be either request/response pairs (e.g. POST /resource) or running executables (e.g. DB migrations).
- Aspects of a test can be generated by user-provided code.

### Goals

- Language agnostic: This should work just as well for an ASP.NET project as a Rails one.
- Comprehensive: All aspects of a response can be asserted (status code, headers, entity, trailers, etc.).
- Strict by default: When something is not specified, the defaults should be as restrictive as possible, e.g. keys not specified in JSON entities are _forbidden_, rather than ignored.
- Concise: If such a default can be provided, it will be.
- Works for REST and GraphQL, etc.: Rather than tying the requests and responses to Resources or Queries, tests should be HTTP-specific, but no moreso.
- Speed: This tool should be fast enough to, if the underlying service is as performant, be used during feature development.

### Design

- Byte-for-byte comparisons work well:
  - Render request and response pair as template strings.
  - Make request.
  - Compare response, byte by byte, with the rendered version. For every template _matcher_ encountered, run the matcher.
- Needs to be smart about parsing headers, etc.
  - Example: Date header. It should be ignored from response assertions, but that requires _parsing_ the headers to know that.
  - Example: Host header. It should be dynamic, based on the host used for testing.
  - Example: HTTP version. It should be optional in response expectations, asserted if and only if present.
- Large bodies: Needs to be able to pull in other files via fixture, etc.

### Alternatives

- Superagent
- Frisby
- Dredd
- Roll-your-own

## Usage

To see the usage information for diplomat, pass the `--help` flag:

```sh
bin/diplomat --help
```

Diplomat accepts one or more files or globs, and a required `--address` argument containing the host URL.

```sh
bin/diplomat examples/simple/pass.txt --address https://httpbin.org
```

### Writing Specifications

In order to define a test in Diplomat, you'll need to provide what we call a _specification_. A specification is a file containing a request and its expected response.

Here's an extremely simple specification, that just checks for a status code (`examples/simple/pass.txt`):

```
You can put any amount of text above the specification in a text file.
Like comments, it will be ignored by the parser.

> GET /status/200 HTTP/1.1
>
< HTTP/1.1 200 OK
< Content-Length: 0
<
```

To run this specification as a test using Diplomat:

```
$ bin/diplomat examples/simple/pass.txt --address https://httpbin.org
✓ GET /status/200 -> 200
```

The command doesn't output any diff information, which means the test passed. Let's look at a specification that we know will fail (`examples/simple/fail.txt`):

```
We don't expect this specification to pass, because the status code and text don't match!

> GET /status/200 HTTP/1.1
>
< HTTP/1.1 422 UNPROCESSABLE ENTITY
< Content-Length: 0
<
```

```
$ bin/diplomat examples/simple/fail.txt --address https://httpbin.org
✗ GET /status/200 -> 422
Status:
        - 422 UNPROCESSABLE ENTITY
        + 200 OK
```

Running this specification through Diplomat provides output that `Status` is not expected.

Currently supported file extensions for specifications: `.txt`, `.md`, `.markdown`.

### Using Curl to Generate Specifications

Something we've kept in mind while developing this project is the concept of [runnable documentation](https://github.blog/2015-10-06-runnable-documentation/). The idea is that a Diplomat specification can be both documentation _and_ a test file. You can build and check in specifications alongside your source code, or create a quick one-off file that can be attached to a ticket to demonstrate an issue.

Specification syntax is based on the output you get from `curl`'s [verbose option](https://ec.haxx.se/usingcurl-verbose.html), which means you can run `curl -v` to generate specifications.

For example:

```
$ curl --verbose https://httpbin.org/status/422
*   Trying 3.85.154.144...
* TCP_NODELAY set
* Connected to httpbin.org (3.85.154.144) port 443 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
* Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH
* successfully set certificate verify locations:
*   CAfile: /etc/ssl/cert.pem
  CApath: none
* TLSv1.2 (OUT), TLS handshake, Client hello (1):
* TLSv1.2 (IN), TLS handshake, Server hello (2):
* TLSv1.2 (IN), TLS handshake, Certificate (11):
* TLSv1.2 (IN), TLS handshake, Server key exchange (12):
* TLSv1.2 (IN), TLS handshake, Server finished (14):
* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):
* TLSv1.2 (OUT), TLS change cipher, Client hello (1):
* TLSv1.2 (OUT), TLS handshake, Finished (20):
* TLSv1.2 (IN), TLS change cipher, Client hello (1):
* TLSv1.2 (IN), TLS handshake, Finished (20):
* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256
* ALPN, server did not agree to a protocol
* Server certificate:
*  subject: CN=httpbin.org
*  start date: Feb 17 00:00:00 2019 GMT
*  expire date: Mar 17 12:00:00 2020 GMT
*  subjectAltName: host "httpbin.org" matched cert's "httpbin.org"
*  issuer: C=US; O=Amazon; OU=Server CA 1B; CN=Amazon
*  SSL certificate verify ok.
> GET /status/422 HTTP/1.1
> Host: httpbin.org
> User-Agent: curl/7.54.0
> Accept: */*
> 
< HTTP/1.1 422 UNPROCESSABLE ENTITY
< Access-Control-Allow-Credentials: true
< Access-Control-Allow-Origin: *
< Content-Type: text/html; charset=utf-8
< Date: Thu, 14 Mar 2019 20:48:15 GMT
< Server: nginx
< Content-Length: 0
< Connection: keep-alive
< 
* Connection #0 to host httpbin.org left intact
```

Notice that the sections in this `curl` output, particularly those prefixed by `>` and `<`, resemble the specification above. Simply delete any line starting with `*`, and any headers you don't need to verify.

### Alternate Printers

#### `--tap`

Diplomat supports tap output, by passing the `tap` flag:

```
$ bin/diplomat --tap examples/simple/pass.txt --address https://httpbin.org
TAP version 13
ok 0 GET /status/200 -> 200
```

#### `--debug`

The `debug` flag provides additional information about the differences between the specification's request and response. This flag should not be used in production.

```
$ bin/diplomat --debug examples/simple/pass.txt --address https://httpbin.org
GET /status/200 -> 200
{*http.Response}.Headers["Access-Control-Allow-Credentials"]:
        -: <non-existent>
        +: "true"
{*http.Response}.Headers["Access-Control-Allow-Origin"]:
        -: <non-existent>
        +: "*"
{*http.Response}.Headers["Connection"]:
        -: <non-existent>
        +: "keep-alive"
{*http.Response}.Headers["Content-Type"]:
        -: <non-existent>
        +: "text/html; charset=utf-8"
{*http.Response}.Headers["Date"]:
        -: <non-existent>
        +: "Mon, 18 Mar 2019 14:04:02 GMT"
{*http.Response}.Headers["Server"]:
        -: <non-existent>
        +: "nginx"
{*http.Response}.Body:
        -: []uint8(nil)
        +: []uint8{}
```

### Using Diplomat Validators

Diplomat provides alternate _validators_ that can be embedded in your specification using the syntax `{? validator ?}`. These validators can be used to write more generalized specifications.

#### json_schema

In this example, we are specifying the validator `json_schema`, which is provided by Diplomat. `json_schema` accepts a [JSON Schema specification](https://json-schema.org/specification.html), and will compare the response body output to that specification instead of looking for an exact match

Note: In this example we're also using the Diplomat helper `file` to load that schema from a file.

`examples/json-schema/spec.txt`:
```
> POST /post HTTP/1.1
> Accept: text/plain
> Content-Type: application/json
The request body
< HTTP/1.1 200 OK
{? json_schema(file("examples/json-schema/post-schema.json")) ?}
```

```
$ bin/diplomat examples/json-schema/spec.txt --address https://httpbin.org
✓ POST /post -> 200
```

The schema given in `examples/json-schema/post-schema.json`:
- only validates two top-level properties: `data` and `headers` (`additionalProperties` as true tells it to ignore any extras)
- checks that the `data` property is a string that matches a given value _exactly_
- checks that the `headers` property contains exactly five properties, listed in `required`
- checks that the `Accept`, `Content-Length`, and `Content-Type` headers match given values _exactly_
- checks that the `Host` and `User-Agent` headers exist with the correct type of "string", but doesn't care about their values

```json
{
  "type": "object",
  "additionalProperties": true,
  "required": [
    "data",
    "headers"
  ],
  "properties": {
    "data": {
      "type": "string",
      "const": "The request body\n"
    },
    "headers": {
      "type": "object",
      "additionalProperties": false,
      "required": [
        "Accept",
        "Content-Length",
        "Content-Type",
        "Host",
        "User-Agent"
      ],
      "properties": {
        "Accept": {
          "type": "string",
          "const": "text/plain"
        },
        "Content-Length": {
          "type": "string",
          "const": "17"
        },
        "Content-Type": {
          "type": "string",
          "const": "application/json"
        },
        "Host": {
          "type": "string"
        },
        "User-Agent": {
          "type": "string"
        }
      }
    }
  }
}
```

Feel free to experiement with the JSON schema in this example. Check out the [JSON Schema specification](https://json-schema.org/specification.html) to learn more about the schema syntax.

### Using Custom Lua Scripts

Diplomat specifications also support the loading of custom [Lua](https://www.lua.org/) scripts, which can be used to add dynamic or calculated values to a specification.

This example shows a specification that's using an `apikey` method instead of providing a hard-coded value. In Diplomat, a _non-validator_ custom Lua script should use the syntax `{{func}}` or `{{ func }}`.

*Note:* Since Diplomat uses spaces to parse first request line (`METHOD /path VERSION`), be cautious when embedding Lua there. In the example below, the first interpolated call to `apikey` _cannot_ contain spaces. Everywhere else, the spaces are optional.

`examples/lua-script/spec.txt`:
```
> GET /response-headers?Apikey={{apikey()}} HTTP/1.1
>
< HTTP/1.1 200 OK
< Apikey: {{ apikey() }}
<
```

In order for this to work, we need to write a Lua script that defines the `apikey` function. To keep the example simple, we'll just return the value we want.

`examples/lua-script/script.lua`
```lua
function apikey()
  return 12345
end
```

Finally, we need to pass our Lua script to Diplomat when running the tests, which can be accomplished with the `--script` CLI argument.

```sh
bin/diplomat examples/lua-script/spec.txt --address https://httpbin.org \
  --script examples/lua-script/script.lua
```

For more information on Lua, check out [the docs](https://www.lua.org/docs.html).

## Development

### Get the Source Code

This project uses a version of Go supporting [modules](https://blog.golang.org/modules2019), which means you can clone the repository anywhere you want. It also handles dependencies without need of secondary tooling such as Glide.

```sh
git clone git@github.com:testdouble/diplomat.git
cd diplomat
```

### Setup

Install [`go`](https://golang.org/doc/install):

```sh
# Mac OSX with Homebrew
brew install go
```

Install [`bats-core`](https://github.com/bats-core/bats-core):

```sh
# Mac OSX with Homebrew
brew install bats-core
```

In order to develop on this repository, you'll also need to install [Docker](https://docs.docker.com/install/).

By default, we use a Docker image version of [`httpbin`](https://httpbin.org/) to make requests for the `bats` tests. If you prefer not to use Docker, change the value of `TEST_HOST` in `test/helpers/helpers.bash` to point to `https://httpbin.org`.

### Watch Code and Run Tests

The core development script in `Makefile` is `watch`:

```sh
make watch
```

This script uses `rg --files | entr -rc` to watch the code, and run several other `make` scripts on update. Those scripts can also be run on a one-off basis, if desired (see `Makefile`). The `watch` script provides a general-purpose, fast feedback cycle for development, which encourages making small changes and keeping tests green.

### Using Mocks

The unit tests in this repository use [`mockery`](http://docs.mockery.io/en/latest/) and [`testify`](https://github.com/stretchr/testify) to generate mocks for each `type` in the project. These mock files live in `mocks`, are checked into source control, and should _not_ be manually updated.

If you add or modify any `type`s, you will need to regenerate the mocks.

```sh
make generate
```

## Code of Conduct

This project follows Test Double's [code of conduct](https://testdouble.com/code-of-conduct) for all community interactions, including (but not limited to) one-on-one communications, public posts/comments, code reviews, pull requests, and GitHub issues. If violations occur, Test Double will take any action they deem appropriate for the infraction, up to and including blocking a user from the organization's repositories.
