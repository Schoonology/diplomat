# Diplomat

While tools like Cypress have evolved to provide concise, dependable end-to-end tests, these tools rely on driving a UI and asserting its state. What is lacking is a similarly concise, similarly dependable, similarly _enjoyable_ tool for driving an HTTP API and asserting its responses. Diplomat aims to meet that need.

Like most TD tools, this tool aims to codify the opinions of its authors for not only a technology, but its influence on the _process_ and _practice_ of making software. Diplomat is opinionated.

## About this Project

### Features

- Makes requests and asserts responses.
- Tests can be preceded by setup, and postceded by teardown.
  - Setup and teardown can be either request/response pairs (e.g. POST /resource) or running executables (e.g. DB migrations).
- Aspects of a test can be generated by user-provided code.

### Goals

- Language agnostic: This should work just as well for an ASP.NET project as a Rails one.
- Comprehensive: All aspects of a response can be asserted (status code, headers, entity, trailers, etc.).
- Strict by default: When something is not specified, the defaults should be as restrictive as possible, e.g. keys not specified in JSON entities are _forbidden_, rather than ignored.
- Concise: If such a default can be provided, it will be.
- Works for REST and GraphQL, etc.: Rather than tying the requests and responses to Resources or Queries, tests should be HTTP-specific, but no moreso.
- Speed: This tool should be fast enough to, if the underlying service is as performant, be used during feature development.

### Design

- Byte-for-byte comparisons work well:
  - Render request and response pair as template strings.
  - Make request.
  - Compare response, byte by byte, with the rendered version. For every template _matcher_ encountered, run the matcher.
- Needs to be smart about parsing headers, etc.
  - Example: Date header. It should be ignored from response assertions, but that requires _parsing_ the headers to know that.
  - Example: Host header. It should be dynamic, based on the host used for testing.
  - Example: HTTP version. It should be optional in response expectations, asserted if and only if present.
- Large bodies: Needs to be able to pull in other files via fixture, etc.

### Alternatives

- Superagent
- Frisby
- Dredd
- Roll-your-own

## Development

### Get the Source Code

This project uses a version of Go supporting [modules](https://blog.golang.org/modules2019), which means you can clone the repository anywhere you want. It also handles depdencies without need of secondary tooling such as Glide.

```sh
git clone git@github.com:testdouble/diplomat.git
cd diplomat
```

### Setup

Install [`bats`](https://github.com/sstephenson/bats) and [go](https://golang.org/doc/install):

```sh
# Mac OSX with Homebrew
brew install bats
brew install go
```

In order to develop on this repository, you'll also need to install Docker.

### Watch Code and Run Tests

The core development script in `Makefile` is `watch`:

```sh
make watch
```

This script uses `rg --files | entr -rc` to watch the code, and run several other `make` scripts on update. Those scripts can also be run on a one-off basis, if desired (see `Makefile`). The `watch` script provides a general-purpose, fast feedback cycle for development, which encourages making small changes and keeping tests green.

### Using Mocks

The unit tests in this repository use [`mockery`](http://docs.mockery.io/en/latest/) and [`testify`](https://github.com/stretchr/testify) to generate mocks for each `type` in the project. These mock files live in `mocks`, are checked into source control, and should _not_ be manually updated.

If you add or modify any `type`s, you will need to regenerate the mocks.

```sh
make generate
```
